[{"name":"Url.Codec","comment":" An alternative to [`Url.Parser`](https://package.elm-lang.org/packages/elm/url/latest/Url-Parser)\nand [`Url.Builder`](https://package.elm-lang.org/packages/elm/url/latest/Url-Builder)\nmodules from the [`elm/url`](https://package.elm-lang.org/packages/elm/url/latest/)\npackage.\n\n**Allows you to define both the URL parser and the URL builder at the same time.**\n\nNote that if you only need an URL parser, the [`Url.SimpleParser`](Url-SimpleParser)\nmodule will be nicer to use while providing the same functionality.\n\n@docs Codec, CodecInProgress\n\n\n## URL parsing\n\n@docs ParseError, parse, parseOneOf\n\n\n## URL building\n\n@docs toString, toStringOneOf\n\n\n## Combinators\n\n@docs succeed, s, int, string\n\n","unions":[{"name":"CodecInProgress","comment":" CodecInProgress is an unfinished codec that needs some more steps to be able\nto fully parse and build URLs.\n\nWhenever you see `CodecInProgress` with two unequal types, you're likely missing\nan argument to your final value somewhere.\n\nYou'll typically start with something like\n\n    type Route\n        = CommentPage String Int\n        | PostPage String\n\n    myCodec =\n        Url.Codec.succeed CommentPage\n\nAt this point, the codec is of type:\n\n    myCodec : CodecInProgress a (String -> Int -> Route)\n\n_(After the first usage of [`int`](#int) or [`string`](#string) this will become\nmore precise: the `a` will become a `Route`.)_\n\nYour goal here is to provide both arguments to `CommentPage`: the `String` and\nthe `Int`. Do that with the [`int`](#int) / [`string`](#string) functions. You\ncan also use the [`s`](#s) (as in \"segment\") function to provide hardcoded\nsegments in the URL path:\n\n    myCodec =\n        Url.Codec.succeed CommentPage\n            |> Url.Codec.s \"post\"\n            |> Url.Codec.string getCommentPageSlug\n            |> Url.Codec.s \"page\"\n            |> Url.Codec.int getCommentPageNumber\n\nNow that we've used both [`string`](#string) and [`int`](#int), this codec will\nbe able to both parse and build URLs:\n\n    Url.Codec.parse myCodec \"post/hello-world/page/1\"\n    --> Ok (CommentPage \"hello-world\" 1)\n\n    Url.Codec.toString myCodec (CommentPage \"you-too\" 222)\n    --> Just \"post/you-too/page/222\"\n\nNote that the [`int`](#int) and [`string`](#string) functions need you to provide\na getter. Here is a typical implementation of one:\n\n    getCommentPageSlug : Route -> Maybe String\n    getCommentPageSlug route =\n        case route of\n            CommentPage slug _ ->\n                Just slug\n\n            _ ->\n                Nothing\n\n_Sidenote: In principle it should be possible to make an `elm-review` rule that\nwould generate these getters for you. The more noise you'll make (ping\n`@janiczek` on the Elm Slack or on Twitter), the better chance it will come into\nexistence :)_\n\n","args":["target","parseResult"],"cases":[]},{"name":"ParseError","comment":" All the ways the parsing can fail.\n","args":[],"cases":[["SegmentMismatch",["{ expected : String.String, available : String.String }"]],["SegmentNotAvailable",[]],["WasNotInt",["String.String"]],["DidNotConsumeEverything",["List.List String.String"]],["NoCodecs",[]]]}],"aliases":[{"name":"Codec","comment":" Codec knows both:\n\n  - how to parse an URL string into Elm data\n  - how to build an URL from Elm data.\n\nCreate it with the combinators [`succeed`](#succeed), [`s`](#s), [`int`](#int)\nand [`string`](#string).\n\nUse it to **parse** URLs with the functions [`parse`](#parse) and\n[`parseOneOf`](#parseOneOf).\n\nUse it to **build** URLs with the functions [`toString`](#toString) and\n[`toStringOneOf`](#toStringOneOf).\n\nLeading and trailing slashes don't matter: don't feel an obligation to sanitize\nyour input!\n\n","args":["target"],"type":"Url.Codec.CodecInProgress target target"}],"values":[{"name":"int","comment":" An integer path segment.\n\n    codec : Codec Route\n    codec =\n        Url.Codec.succeed UserRoute\n            |> Url.Codec.s \"user\"\n            |> Url.Codec.int getUserRouteId\n\n    getUserRouteId : Route -> Maybe Int\n    getUserRouteId route =\n        case route of\n            UserRoute id ->\n                Just id\n\n            _ ->\n                Nothing\n\n    Url.Codec.parse codec \"user/123\"\n    --> Ok (UserRoute 123)\n\n    Url.Codec.toString codec (UserRoute 999)\n    --> Just \"user/999\"\n\n","type":"(target -> Maybe.Maybe Basics.Int) -> Url.Codec.CodecInProgress target (Basics.Int -> parseResult) -> Url.Codec.CodecInProgress target parseResult"},{"name":"parse","comment":" Parse the URL path string using the provided codec.\n\n    Url.Codec.parse helloCodec \"hello/123\"\n    --> Ok (HelloPage 123)\n\n    Url.Codec.parse helloCodec \"hello/123whoops\"\n    --> Err (WasNotInt \"123whoops\")\n\n","type":"Url.Codec.Codec parseResult -> String.String -> Result.Result Url.Codec.ParseError parseResult"},{"name":"parseOneOf","comment":" Parse the URL path string, trying out multiple codecs if necessary.\n\nWill stop at the first success.\n\nIn case of errors will present an error from the codec that had the most success\nbefore failing.\n\nIn case two codec failed at the same depth, will prefer the later one.\n\n    allCodecs =\n        [ helloCodec, homeCodec ]\n\n    Url.Codec.parseOneOf allCodecs \"hello/123\"\n    --> Ok (HelloPage 123)\n\n    Url.Codec.parseOneOf allCodecs \"\"\n    --> Ok HomePage\n\n    Url.Codec.parseOneOf [] \"\"\n    --> Err NoCodecs\n\n","type":"List.List (Url.Codec.Codec parseResult) -> String.String -> Result.Result Url.Codec.ParseError parseResult"},{"name":"s","comment":" A hardcoded path segment.\n\n    codec : Codec Route\n    codec =\n        Url.Codec.succeed HomeRoute\n            |> Url.Codec.s \"home\"\n\n    Url.Codec.parse coded \"home\"\n    --> Ok HomeRoute\n\n    Url.Codec.toString codec HomeRoute\n    --> Just \"home\"\n\n","type":"String.String -> Url.Codec.CodecInProgress target parseResult -> Url.Codec.CodecInProgress target parseResult"},{"name":"string","comment":" A string path segment.\n\n    codec : Codec Route\n    codec =\n        Url.Codec.succeed PostRoute\n            |> Url.Codec.s \"post\"\n            |> Url.Codec.string getPostRouteSlug\n\n    getPostRouteSlug : Route -> Maybe String\n    getPostRouteSlug route =\n        case route of\n            PostRoute slug ->\n                Just slug\n\n            _ ->\n                Nothing\n\n    Url.Codec.parse codec \"post/hello\"\n    --> Ok (PostRoute \"hello\")\n\n    Url.Codec.toString codec (PostRoute \"hiya\")\n    --> Just \"post/hiya\"\n\n","type":"(target -> Maybe.Maybe String.String) -> Url.Codec.CodecInProgress target (String.String -> parseResult) -> Url.Codec.CodecInProgress target parseResult"},{"name":"succeed","comment":" A way to start your Codec definition.\n\n    unfinishedCodec : CodecInProgress Route (String -> Route)\n    unfinishedCodec =\n        -- needs a string provided via Url.Codec.string\n        Url.Codec.succeed UserRoute\n\nCan also work standalone for URLs without path segments:\n\n    codec : Codec Route\n    codec =\n        Url.Codec.succeed HomeRoute\n\n    Url.Codec.parse codec \"\"\n    --> Ok HomeRoute\n\n    Url.Codec.toString codec HomeRoute\n    --> Just \"\"\n\n","type":"parseResult -> Url.Codec.CodecInProgress target parseResult"},{"name":"toString","comment":" Convert the given value into an URL string.\n\nCan fail (eg. if you use a codec for one route with a string belonging to a\ndifferent route, such that the getters will return Nothing).\n\n    Url.Codec.toString helloCodec (HelloPage 123)\n    --> Just \"hello/123\"\n\n","type":"Url.Codec.Codec target -> target -> Maybe.Maybe String.String"},{"name":"toStringOneOf","comment":" Convert the given value into an URL string, trying out multiple codecs if\nnecessary.\n\nWill stop at the first success.\n\nCan fail (eg. if you use a codec for one route with a string belonging to a\ndifferent route, such that the used getters will return Nothing).\n\n    allCodecs =\n        [ helloCodec, postCodec ]\n\n    Url.Codec.toString allCodecs (HelloPage 123)\n    --> Just \"hello/123\"\n\n    Url.Codec.toString allCodecs (PostPage \"goto-bad\")\n    --> Just \"post/goto-bad\"\n\n","type":"List.List (Url.Codec.Codec target) -> target -> Maybe.Maybe String.String"}],"binops":[]},{"name":"Url.SimpleParser","comment":" A simpler alternative to [`Url.Parser`](https://package.elm-lang.org/packages/elm/url/latest/Url-Parser)\nmodule from the [`elm/url`](https://package.elm-lang.org/packages/elm/url/latest/)\npackage.\n\nNote that if you want to build both URL parsers and builders at the same time,\nyou should use the [`Url.Codec`](Url-Codec) module instead. The API is very similar!\n\n\n## URL parsing\n\n@docs Parser, ParseError, parse, parseOneOf\n\n\n## Combinators\n\n@docs succeed, s, int, string\n\n","unions":[{"name":"ParseError","comment":" All the ways the parsing can fail.\n","args":[],"cases":[["SegmentMismatch",["{ expected : String.String, available : String.String }"]],["SegmentNotAvailable",[]],["WasNotInt",["String.String"]],["DidNotConsumeEverything",["List.List String.String"]],["NoParsers",[]]]},{"name":"Parser","comment":" Parser knows how to parse an URL string into Elm data.\n\nCreate it with the combinators [`succeed`](#succeed), [`s`](#s), [`int`](#int)\nand [`string`](#string).\n\nUse it to parse URLs with the functions [`parse`](#parse) and\n[`parseOneOf`](#parseOneOf).\n\nLeading and trailing slashes don't matter: don't feel an obligation to sanitize\nyour input!\n\n","args":["a"],"cases":[]}],"aliases":[],"values":[{"name":"int","comment":" An integer path segment.\n\n    parser : Parser Route\n    parser =\n        Url.SimpleParser.succeed UserRoute\n            |> Url.SimpleParser.s \"user\"\n            |> Url.SimpleParser.int\n\n    Url.SimpleParser.parse parser \"user/123\"\n    --> Ok (UserRoute 123)\n\n","type":"Url.SimpleParser.Parser (Basics.Int -> a) -> Url.SimpleParser.Parser a"},{"name":"parse","comment":" Parse the URL path string using the provided parser.\n\n    Url.SimpleParser.parse helloParser \"hello/123\"\n    --> Ok (HelloPage 123)\n\n    Url.SimpleParser.parse helloParser \"hello/123whoops\"\n    --> Err (WasNotInt \"123whoops\")\n\n","type":"Url.SimpleParser.Parser a -> String.String -> Result.Result Url.SimpleParser.ParseError a"},{"name":"parseOneOf","comment":" Parse the URL path string, trying out multiple parsers if necessary.\n\nWill stop at the first success.\n\nIn case of errors will present an error from the parser that had the most success\nbefore failing.\n\nIn case two parsers failed at the same depth, will prefer the later one.\n\n    allParsers =\n        [ helloParser, homeParser ]\n\n    Url.SimpleParser.parseOneOf allParsers \"hello/123\"\n    --> Ok (HelloPage 123)\n\n    Url.SimpleParser.parseOneOf allParsers \"\"\n    --> Ok HomePage\n\n    Url.SimpleParser.parseOneOf [] \"\"\n    --> Err NoParsers\n\n","type":"List.List (Url.SimpleParser.Parser a) -> String.String -> Result.Result Url.SimpleParser.ParseError a"},{"name":"s","comment":" A hardcoded path segment.\n\n    parser : Parser Route\n    parser =\n        Url.SimpleParser.succeed HomeRoute\n            |> Url.SimpleParser.s \"home\"\n\n    Url.SimpleParser.parse parser \"home\"\n    --> Ok HomeRoute\n\n","type":"String.String -> Url.SimpleParser.Parser a -> Url.SimpleParser.Parser a"},{"name":"string","comment":" A string path segment.\n\n    parser : Parser Route\n    parser =\n        Url.SimpleParser.succeed PostRoute\n            |> Url.SimpleParser.s \"post\"\n            |> Url.SimpleParser.string\n\n    Url.SimpleParser.parse parser \"post/hello\"\n    --> Ok (PostRoute \"hello\")\n\n","type":"Url.SimpleParser.Parser (String.String -> a) -> Url.SimpleParser.Parser a"},{"name":"succeed","comment":" A way to start your Parser definition.\n\nCan also work standalone for URLs without path segments:\n\n    parser : Parser Route\n    parser =\n        Url.SimpleParser.succeed HomeRoute\n\n    Url.SimpleParser.parse parser \"\"\n    --> Ok HomeRoute\n\n","type":"a -> Url.SimpleParser.Parser a"}],"binops":[]}]